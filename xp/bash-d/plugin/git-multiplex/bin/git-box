#!/bin/bash

# cat ~/.gitbox.conf
#
# ~/xpkit fetch,push
# ~/wiki
# ~

# option: sequence of action to do:
#         add-all       a
#         commit        c
#         fetch         f
#         merge-ff      m
#         rebase        r
#         push          p

#include '_git_xp_lib.sh' begin
#!/bin/sh

_git_xp_verbose=1
_git_log_before=''
_git_log_after=''

die()
{
    echo "Failure $@" >&2
    exit 1
}
die_empty()
{
    if test -z "$1"
    then
        shift
        die empty: "$@"
    fi
}

set_verbose()
{
    _git_xp_verbose=${1-1}
}

log()
{
    local color="$1"
    local title="$2"
    shift
    shift

    local mes="$@"
    local NC="$(tput sgr0)"

    if [ -t 1 ]; then
        title="${color}${title}${NC}"
    fi
    echo "$(eval "$_git_log_before")""$title $mes""$(eval "$_git_log_after")"
}
dd()
{
    debug "$@"
}
debug()
{
    if [ ".$_git_xp_verbose" = ".1" ]; then
        local LightCyan="$(tput bold ; tput setaf 6)"
        log "$LightCyan" "$@"
    fi
}
info()
{
    local Brown="$(tput setaf 3)"
    log "$Brown" "$@"
}
mes()
{
    local Green="$(tput setaf 2)"
    log "$Green" "$@"
}
ok() {
    local Green="$(tput setaf 2)"
    log "${Green}"  "ok:  $@"
}
err() {
    local Red="$(tput setaf 1)"
    log "${Red}"    "err: $@"
}

_init_colors()
{
    Black="$(tput setaf 0)"
    BlackBG="$(tput setab 0)"
    DarkGrey="$(tput bold ; tput setaf 0)"
    LightGrey="$(tput setaf 7)"
    LightGreyBG="$(tput setab 7)"
    White="$(tput bold ; tput setaf 7)"
    Red="$(tput setaf 1)"
    RedBG="$(tput setab 1)"
    LightRed="$(tput bold ; tput setaf 1)"
    Green="$(tput setaf 2)"
    GreenBG="$(tput setab 2)"
    LightGreen="$(tput bold ; tput setaf 2)"
    Brown="$(tput setaf 3)"
    BrownBG="$(tput setab 3)"
    Yellow="$(tput bold ; tput setaf 3)"
    Blue="$(tput setaf 4)"
    BlueBG="$(tput setab 4)"
    LightBlue="$(tput bold ; tput setaf 4)"
    Purple="$(tput setaf 5)"
    PurpleBG="$(tput setab 5)"
    Pink="$(tput bold ; tput setaf 5)"
    Cyan="$(tput setaf 6)"
    CyanBG="$(tput setab 6)"
    LightCyan="$(tput bold ; tput setaf 6)"
    NC="$(tput sgr0)" # No Color
}

git_hash()
{
    git rev-parse $1 \
        || die "'git_hash $@'"
}
git_rev_list()
{
    # --parents
    # print parent in this form:
    #     <commit> <parent-1> <parent-2> ..

    git rev-list \
        --reverse \
        --topo-order \
        --default HEAD \
        --simplify-merges \
        "$@" \
        || die "'git rev-list $@'"
}
git_ver()
{
    local git_version=$(git --version | awk '{print $NF}')
    local git_version_1=${git_version%%.*}
    local git_version_2=${git_version#*.}
    git_version_2=${git_version_2%%.*}

    printf "%03d%03d" $git_version_1 $git_version_2
}
git_working_root()
{
    git rev-parse --show-toplevel
}

git_branch_default_remote()
{
    local branchname=$1
    git config --get branch.${branchname}.remote
}
git_branch_default_upstream_ref()
{
    local branchname=$1
    git config --get branch.${branchname}.merge
}
git_branch_default_upstream()
{
    git_branch_default_upstream_ref "$@" | sed 's/^refs\/heads\///'
}

git_head_branch()
{
    git symbolic-ref --short HEAD
}
#include '_git_xp_lib.sh' end

set_verbose 1
_init_colors

_git_log_before=_date
_git_log_after=get_pwd

_convert_option()
{
    local option=$1
    local actions="$option"

    case $option in
        fetchonly)
            actions="fetch"
            ;;
        fetchpush)
            actions="fetch,merge-ff,push"
            ;;
        "")
            actions="add-all,commit,fetch,rebase,push"
            ;;
    esac
    echo $actions
}


_has_act()
{
    local actions=",$1,"
    local act="$2"
    expr "$actions" : ".*,$act,.*" >/dev/null
}


_date() {
    date +"%Y-%m-%d %H:%M:%S "
}


get_pwd() {
    local _pwd=$(pwd)
    local p=${1-$_pwd}
    local home=$HOME
    local stripped=${p#$home}
    if [ ".$stripped" == ".$p" ]; then
        :
    else
        stripped="~$stripped"
    fi
    echo -n " $stripped"
}


_sleep()
{
    if mac-power is-battery
    then
        echo using battery.. sleep 10 minutes
        sleep 60*10
    else
        sleep 10
    fi
}


sync_once()
{
    local conffn="${GITBOX_CONF_FN-$HOME/.gitbox.conf}"

    if [ ! -f $conffn ]
    then
        echo "no conf file: $conffn"
        return 0
    fi

    while read path option; do

        if test ".$path" = "." || expr "$path" : "[ 	]*#" >/dev/null
        then
            continue
        fi

        actions="$(_convert_option "$option")"

        # change ~ to real home path, and expand *
        eval "ls -dp $path" | while read p; do

            if test ! -d "$p/.git"; then
                continue
            fi

            (
            cd "$p" || die not-found: "$p"

            branch=$(git_head_branch)
            upstream=$(git_branch_default_upstream $branch)
            mes "actions:  $actions"
            mes "branch:   ($branch)"
            mes "upstream: ($upstream)"

            if _has_act $actions add-all; then
                git add .
                git add -u .
            fi

            if _has_act $actions commit; then
                mes="$(git status --short --ignore-submodules --untracked-files=no | head -n1)"
                git commit -m "$mes" >/dev/null \
                    && ok "    commit"
            fi

            if _has_act $actions "fetch.*"; then

                local arg=""
                if _has_act $actions "fetch-p"; then
                    arg=" --prune "
                fi

                git fetch --all --quiet $arg \
                    && ok  "    fetch" \
                    || err "    fetch"
            fi

            if _has_act $actions rebase; then
                git rebase origin/$upstream --quiet \
                    && ok  "    rebase onto origin/$upstream" \
                    || err "    rebase onto origin/$upstream"
            fi

            if _has_act $actions merge-ff; then
                if test -n "$branch"; then
                    git merge --no-edit --commit --ff-only \
                        && ok  "    merge-ff" \
                        || err "    merge-ff"
                else
                    mes "HEAD is not a branch, skip merge"
                fi
            fi

            if _has_act $actions push; then
                if test -n "$branch"; then
                    while read remote
                    do
                        git push $remote $branch --quiet \
                            && ok  "    push to $remote" \
                            || err "    push to $remote"

                    done<<<"$(git remote)"
                else
                    mes "HEAD is not a branch, skip push"
                fi
            fi
            )
        done

    done <$conffn
}


main() {

    running=1

    trap 'running=0; echo killing mypid: $$, subprocess: $sync_pid, $kill_pid; kill $sync_pid $kill_pid' SIGINT SIGTERM EXIT

    while test "$running" = "1"; do

        {
            mes box-sync-start...
            sync_once
            mes sync-done
        } &
        sync_pid="$!"

        {
            sleep 1800
            kill $sync_pid
            err sync-timeout, killed $sync_pid
        } &
        kill_pid="$!"

        # if sync_pid done, cancel killing
        # if sync_pid timed out, kill_pid will kill it, makes it return.
        wait $sync_pid 2>/dev/null \
            && kill $kill_pid \
            || echo wait for sync process $sync_pid timeout

        _sleep

    done
}

main
