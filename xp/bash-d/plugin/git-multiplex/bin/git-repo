#!/bin/sh

PATH=$PATH:$(git --exec-path)
. git-sh-setup

#include '_git_xp_lib.sh' begin
#!/bin/sh

_git_xp_verbose=1

die()
{
    echo "Failure $@" >&2
    exit 1
}
die_empty()
{
    if test -z "$1"
    then
        shift
        die empty: "$@"
    fi
}

set_verbose()
{
    _git_xp_verbose=${1-1}
}
log()
{
    local color="$1"
    local title="$2"
    shift
    shift

    local mes="$@"
    local NC="$(tput sgr0)"

    if [ -t 1 ]; then
        echo "$color$title$NC $mes"
    else
        echo "$title $mes"
    fi
}
dd()
{
    debug "$@"
}
debug()
{
    if [ ".$_git_xp_verbose" = ".1" ]; then
        local LightCyan="$(tput bold ; tput setaf 6)"
        log "$LightCyan" "$@"
    fi
}
info()
{
    local Brown="$(tput setaf 3)"
    log "$Brown" "$@"
}
mes()
{
    local Green="$(tput setaf 2)"
    log "$Green" "$@"
}

_colors()
{
    Black="$(tput setaf 0)"
    BlackBG="$(tput setab 0)"
    DarkGrey="$(tput bold ; tput setaf 0)"
    LightGrey="$(tput setaf 7)"
    LightGreyBG="$(tput setab 7)"
    White="$(tput bold ; tput setaf 7)"
    Red="$(tput setaf 1)"
    RedBG="$(tput setab 1)"
    LightRed="$(tput bold ; tput setaf 1)"
    Green="$(tput setaf 2)"
    GreenBG="$(tput setab 2)"
    LightGreen="$(tput bold ; tput setaf 2)"
    Brown="$(tput setaf 3)"
    BrownBG="$(tput setab 3)"
    Yellow="$(tput bold ; tput setaf 3)"
    Blue="$(tput setaf 4)"
    BlueBG="$(tput setab 4)"
    LightBlue="$(tput bold ; tput setaf 4)"
    Purple="$(tput setaf 5)"
    PurpleBG="$(tput setab 5)"
    Pink="$(tput bold ; tput setaf 5)"
    Cyan="$(tput setaf 6)"
    CyanBG="$(tput setab 6)"
    LightCyan="$(tput bold ; tput setaf 6)"
    NC="$(tput sgr0)" # No Color
}

git_hash()
{
    git rev-parse $1 \
        || die "'git_hash $@'"
}
git_rev_list()
{
    # --parents
    # print parent in this form:
    #     <commit> <parent-1> <parent-2> ..

    git rev-list \
        --reverse \
        --topo-order \
        --default HEAD \
        --simplify-merges \
        "$@" \
        || die "'git rev-list $@'"
}
git_ver()
{
    local git_version=$(git --version | awk '{print $NF}')
    local git_version_1=${git_version%%.*}
    local git_version_2=${git_version#*.}
    git_version_2=${git_version_2%%.*}

    printf "%03d%03d" $git_version_1 $git_version_2
}
git_working_root()
{
    git rev-parse --show-toplevel
}

git_branch_default_remote()
{
    local branchname=$1
    git config --get branch.${branchname}.remote
}
git_branch_default_upstream_ref()
{
    local branchname=$1
    git config --get branch.${branchname}.merge
}
git_branch_default_upstream()
{
    git_branch_default_upstream_ref "$@" | sed 's/^refs\/heads\///'
}

git_head_branch()
{
    git symbolic-ref --short HEAD
}
#include '_git_xp_lib.sh' end

dd "git dir: $GIT_DIR"

# cat <<-END
# dir:    "dir/path"
# remote: origin  git://github.com/jquery/jquery-tmpl.git
# remote: bkp     git://github.com/jquery/jquery-tmpl.git
# head:   origin  master
# END

init()
{
    working_dir="$(git_working_root)"
    die_empty "$working_dir" no git working dir found

    conf_fn="$working_dir/.gitrepo"
    test -r "$conf_fn" \
        || die "$conf_fn" is unreadable
}

doit()
{
    local k=
    local a1=
    local a2=

    local dirpath=
    local remote=
    local url=
    local tip=
    local repo_path=

    local state=nil

    { cat "$conf_fn"; echo ""; } | while read k a1 a2; do

        case "$k" in
            '')
                if test -z "$dirpath"; then
                    dd "no conf read, continue"
                    continue
                fi
                repo_path="$working_dir/$dirpath"

                if test -d "$repo_path"; then
                fi

                # dirpath=
                # remote=
                # url=
                # tip=
                ;;

            dir:)
                dirpath="$a1"
                dd "find dir: $dirpath"
                ;;

            remote:)
                remote="$a1"
                url="$a2"
                dd "remote: $remote : $url"
                ;;
            head:)
                head="$a1"
                dd "head: $head"
                ;;
        esac
    done

    dd "finished"
}

main()
{
    init
    doit
}


main "$@"
