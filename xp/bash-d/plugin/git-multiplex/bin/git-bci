#!/bin/bash

#include '_git_xp_lib.sh' begin
#!/bin/sh

_git_xp_verbose=1
_git_log_before=''
_git_log_after=''

die()
{
    echo "Failure $@" >&2
    exit 1
}
die_empty()
{
    if test -z "$1"
    then
        shift
        die empty: "$@"
    fi
}

set_verbose()
{
    _git_xp_verbose=${1-1}
}

log()
{
    local color="$1"
    local title="$2"
    shift
    shift

    local mes="$@"
    local NC="$(tput sgr0)"

    if [ -t 1 ]; then
        title="${color}${title}${NC}"
    fi
    echo "$(eval "$_git_log_before")""$title $mes""$(eval "$_git_log_after")"
}
dd()
{
    debug "$@"
}
debug()
{
    if [ ".$_git_xp_verbose" = ".1" ]; then
        local LightCyan="$(tput bold ; tput setaf 6)"
        log "$LightCyan" "$@"
    fi
}
info()
{
    local Brown="$(tput setaf 3)"
    log "$Brown" "$@"
}
mes()
{
    local Green="$(tput setaf 2)"
    log "$Green" "$@"
}
ok() {
    local Green="$(tput setaf 2)"
    log "${Green}"  "ok:  $@"
}
err() {
    local Red="$(tput setaf 1)"
    log "${Red}"    "err: $@"
}

_init_colors()
{
    Black="$(tput setaf 0)"
    BlackBG="$(tput setab 0)"
    DarkGrey="$(tput bold ; tput setaf 0)"
    LightGrey="$(tput setaf 7)"
    LightGreyBG="$(tput setab 7)"
    White="$(tput bold ; tput setaf 7)"
    Red="$(tput setaf 1)"
    RedBG="$(tput setab 1)"
    LightRed="$(tput bold ; tput setaf 1)"
    Green="$(tput setaf 2)"
    GreenBG="$(tput setab 2)"
    LightGreen="$(tput bold ; tput setaf 2)"
    Brown="$(tput setaf 3)"
    BrownBG="$(tput setab 3)"
    Yellow="$(tput bold ; tput setaf 3)"
    Blue="$(tput setaf 4)"
    BlueBG="$(tput setab 4)"
    LightBlue="$(tput bold ; tput setaf 4)"
    Purple="$(tput setaf 5)"
    PurpleBG="$(tput setab 5)"
    Pink="$(tput bold ; tput setaf 5)"
    Cyan="$(tput setaf 6)"
    CyanBG="$(tput setab 6)"
    LightCyan="$(tput bold ; tput setaf 6)"
    NC="$(tput sgr0)" # No Color
}

git_hash()
{
    git rev-parse $1 \
        || die "'git_hash $@'"
}
git_is_merge()
{
    test $(git cat-file -p "$1" | grep "^parent " | wc -l) -gt 1
}
git_parents()
{
    git rev-list --parents -n 1 ${1-HEAD} | { read self parents; echo $parents; }
}
git_rev_list()
{
    # --parents
    # print parent in this form:
    #     <commit> <parent-1> <parent-2> ..

    git rev-list \
        --reverse \
        --topo-order \
        --default HEAD \
        --simplify-merges \
        "$@" \
        || die "'git rev-list $@'"
}
git_tree_hash()
{
    git rev-parse "$1^{tree}"
}
git_ver()
{
    local git_version=$(git --version | awk '{print $NF}')
    local git_version_1=${git_version%%.*}
    local git_version_2=${git_version#*.}
    git_version_2=${git_version_2%%.*}

    printf "%03d%03d" $git_version_1 $git_version_2
}
git_working_root()
{
    git rev-parse --show-toplevel
}

git_branch_default_remote()
{
    local branchname=$1
    git config --get branch.${branchname}.remote
}
git_branch_default_upstream_ref()
{
    local branchname=$1
    git config --get branch.${branchname}.merge
}
git_branch_default_upstream()
{
    git_branch_default_upstream_ref "$@" | sed 's/^refs\/heads\///'
}

git_head_branch()
{
    git symbolic-ref --short HEAD
}
#include '_git_xp_lib.sh' end

# to commit index on to its own branch and merge it back

dest_branch=""
commit_mes=""
find_parent=0

init()
{ #{{{
    arg_no_edit="--no-edit"
    local v=$(git_ver)
    if [ "$v" -lt "001008" ]; then
        arg_no_edit=""
    fi
} #}}}

load_opts()
{ #{{{
    while getopts b:m:p opname; do
        case $opname in
            b)
                dest_branch=$OPTARG
                ;;
            m)
                commit_mes="$OPTARG"
                ;;
            p)
                find_parent=1
                ;;
            *)
                echo invalid
                exit
                ;;
        esac
    done
} #}}}

find_fn_branch()
{ #{{{
    local fns="$1"

    local branches=$(git file-branch $fns | grep --line-buffered -v "^remotes/" | head -n2)

    # for new file, find its parents
    if [ ".$branches" = "." ] && [ "$find_parent" = "1" ]; then
        branches=$(git file-branch -p $fns | grep --line-buffered -v "^remotes/" | head -n2)
    fi

    local nr=$(echo "$branches" | wc -l | sed 's/^[[:space:]]*//')

    if [ ".$branches" = "." ]; then
        echo "error looking up branches" >&2
        exit 1
    fi

    if [ ${nr} = "1" ]; then
        echo "$branches"
    else
        echo "files in '$nr' branches: '$fns': '$(echo $branches)'" >&2
        exit 1
    fi
} #}}}

get_mode()
{
    local mode_fn="$1"
    echo "${mode_fn:0:1}"
}

get_fn()
{
    local mode_fn="$1"
    local lr="$2"

    local mode=$(get_mode "$mode_fn")
    local fns="${mode_fn:3}"

    git-parse-renaming-fn "$fns" "$lr"
}

tt () {
    echo $1
    echo $2
}

init
load_opts "$@"

cur_branch=$(git rev-parse --symbolic-full-name HEAD)

if [ ".${cur_branch%%/*}" != ".refs" ]; then
    echo "not on a branch" >&2
    exit 1;
fi
cur_branch=${cur_branch##refs/heads/}
echo "current branch: '$cur_branch'" >&2

(

# go to repo root since git-status --porcelain use absolute path
cd $(git rev-parse --show-toplevel)

if [ ".$dest_branch" != "." ]; then

    saved=$(git-snapshot save)

    fns=$(git status --porcelain --ignore-submodules |  grep "^[RMAD]" | cut -c 4-)

    commit_mes=${commit_mes:-commit $fns}

    git checkout $(git rev-parse --show-toplevel) \
        && git checkout $dest_branch \
        && git commit --verbose -m "$commit_mes"\
        && git checkout $cur_branch \
        && git merge $arg_no_edit --commit --no-ff $dest_branch \
        && git-snapshot load $saved \
        && echo "merged $fns"
else

    while ``; do

        saved=$(git-snapshot save)

        fns="$(git status --porcelain --ignore-submodules |  grep "^[RMAD]")"
        if [ ".$fns" = "." ]; then
            echo "done"
            break
        fi

        mes="${commit_mes:-commit $fns}"

        index_tree_hash=$(git write-tree)

        mode_fn_1=$(echo "$fns" | head -n1)
        fn_1="$(get_fn "$mode_fn_1" left)"
        br_1=$(find_fn_branch "$fn_1")
        if [ ".$br_1" = "." ]; then
            exit 1
        fi

        commit_fns=""

        oldIFS="$IFS"
        IFS='
'
        for mode_fn in $fns; do

            mode="$(get_mode "$mode_fn")"
            fn="$(get_fn "$mode_fn" left)"

            fbr=$(find_fn_branch "$fn")
            echo "found: '$mode_fn' in branch: '$fbr'" >&2

            if [ "$br_1" = "$fbr" ]; then
                if [ ".$mode" = ".R" ]; then
                    dst="$(get_fn "$mode_fn" right)"
                    echo "add '$fn -> $dst' to commits" >&2
                    commit_fns="$commit_fns '$fn -> $dst'"
                else
                    echo "add '$fn' to commits" >&2
                    commit_fns="$commit_fns '$fn'"
                fi
            else
                if [ ".$mode" = ".R" ]; then
                    dst="$(get_fn "$mode_fn" right)"
                    echo "reset -- '$fn -> $dst'" >&2
                    git reset -- "$fn" "$dst" >/dev/null
                else
                    echo "reset -- '$fn'" >&2
                    git reset -- "$fn" >/dev/null
                fi
            fi
        done
        IFS="$oldIFS"

        echo "partial index to commit:" >&2
        git status --short >&2

        git checkout -q $(git rev-parse --show-toplevel)\
            && git checkout -q $br_1 \
            && git commit -m "$mes" >/dev/null\
            && git checkout -q $cur_branch\
            && git merge $arg_no_edit --commit --no-ff $br_1 >/dev/null \
            && git-snapshot load $saved >/dev/null \
            && echo "merged: '$br_1'. fns:$commit_fns"

        git status --short >&2

    done

fi
)
